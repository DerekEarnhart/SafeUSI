Thought for 10s

Perfect—here’s a more complete, all-local dashboard with three tools in one page:

Beale #2 Verifier (auto-extracts the numbered Declaration block from a pasted pamphlet and decodes Paper “2”).

Generic Book-Cipher Decoder (you paste numbers and a book/key separately; strict first-letter rule; full metrics + JSON artifacts).

Free-Text Generator (sandbox) clearly labeled as non-crypto.

Drop this in as index.html and open it. No APIs, no servers, fully deterministic in the browser.

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Hodge Cipher Dashboard — Lab Suite</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
<style>
  body{font-family:'Inter',sans-serif;background:#0d1117;color:#c9d1d9}
  .card{background:#161b22;border:1px solid #30363d}
  .btn{background:#216e39;color:#c9d1d9;border:1px solid #2ea043;transition:.2s}
  .btn:hover{background:#2ea043}
  .muted{color:#9aa6b2}
  .pill{border:1px solid #30363d;background:#0f141a}
  .input{background:#0d1117;border:1px solid #30363d;color:#c9d1d9}
  .result{background:#0d1117;border:1px dashed #30363d;white-space:pre-wrap;word-wrap:break-word}
  .active{background:#0e7490}
</style>
</head>
<body class="p-4 md:p-8 min-h-screen">
<div class="max-w-6xl mx-auto">

  <header class="mb-6">
    <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-indigo-500">
      Hodge Cipher Dashboard — Lab Suite
    </h1>
    <p class="muted mt-1">Deterministic cryptanalysis, auditable metrics, zero network calls.</p>
  </header>

  <!-- Mode Tabs -->
  <div class="flex flex-wrap gap-2 mb-6">
    <button id="tabBeale" class="pill px-3 py-1 rounded text-sm font-semibold active">Beale #2 Verifier</button>
    <button id="tabBook"  class="pill px-3 py-1 rounded text-sm font-semibold">Generic Book-Cipher</button>
    <button id="tabFree"  class="pill px-3 py-1 rounded text-sm font-semibold">Free-Text Generator (non-crypto)</button>
    <span class="ml-auto text-xs muted flex items-center gap-2">
      <span class="w-2 h-2 bg-green-500 rounded-full"></span> Local engine • Reproducible
    </span>
  </div>

  <main class="grid grid-cols-1 md:grid-cols-2 gap-6">

    <!-- Left Column -->
    <section class="space-y-6">
      <!-- Panel: Inputs -->
      <div class="card p-5 rounded">
        <h2 id="leftTitle" class="text-xl font-semibold mb-2">Beale Paper “2” — Paste the pamphlet excerpt</h2>
        <p id="leftHelp" class="muted text-sm mb-3">
          Include the numbered Declaration block and the long number list for Paper “2”.
          The tool will extract the DOI wordlist and decode strictly by first-letter indexing.
        </p>

        <!-- Beale input -->
        <textarea id="inputBeale" rows="10" class="w-full input rounded p-3 mb-4" placeholder="Paste the 1885 pamphlet excerpt…"></textarea>

        <!-- Book-cipher inputs -->
        <div id="bookInputs" class="hidden">
          <label class="text-sm font-semibold">Cipher Numbers (comma/space separated)</label>
          <textarea id="bookNums" rows="5" class="w-full input rounded p-3 mb-3" placeholder="e.g. 115, 73, 24, 807, 37, 52, …"></textarea>
          <label class="text-sm font-semibold">Book / Key Text</label>
          <textarea id="bookKey" rows="7" class="w-full input rounded p-3" placeholder="Paste the candidate key (book text)…"></textarea>
        </div>

        <!-- Free text input -->
        <div id="freeInputs" class="hidden">
          <label class="text-sm font-semibold">Seed Text (for stylistic mock output)</label>
          <textarea id="freeSeed" rows="8" class="w-full input rounded p-3" placeholder="Paste anything; tool will produce stylistic prose. Not cryptanalysis."></textarea>
        </div>

        <div class="mt-4 flex flex-wrap gap-3">
          <button id="runBtn" class="btn px-4 py-2 rounded font-semibold">Run</button>
          <button id="downloadBtn" class="px-4 py-2 rounded font-semibold border border-gray-700 hover:bg-gray-800 hidden">Download JSON Artifacts</button>
          <span id="warn" class="muted text-xs"></span>
        </div>
      </div>

      <!-- Panel: Status & Notes -->
      <div class="card p-5 rounded">
        <h3 class="text-lg font-semibold mb-2">Status</h3>
        <ul class="text-sm space-y-1">
          <li class="flex items-center gap-2"><span class="w-2 h-2 bg-green-500 rounded-full"></span> Deterministic, letters-only decoding</li>
          <li class="flex items-center gap-2"><span class="w-2 h-2 bg-green-500 rounded-full"></span> Coverage metric + alt-key calibration</li>
          <li class="flex items-center gap-2"><span class="w-2 h-2 bg-green-500 rounded-full"></span> JSON artifacts for provenance</li>
        </ul>
      </div>
    </section>

    <!-- Right Column -->
    <section class="space-y-6">
      <!-- Panel: Output -->
      <div class="card p-5 rounded">
        <h2 class="text-xl font-semibold mb-3">Output</h2>
        <div class="grid grid-cols-2 gap-2 text-xs mb-3">
          <div class="p-2 rounded pill">
            <div class="muted">Coverage</div>
            <div id="covLabel" class="font-semibold">—</div>
          </div>
          <div class="p-2 rounded pill">
            <div class="muted">Alt-Key Rank</div>
            <div id="rankLabel" class="font-semibold">—</div>
          </div>
        </div>

        <h4 class="text-sm font-semibold">Raw Letters (strict index→word→first-letter)</h4>
        <div id="lettersBox" class="result rounded p-3 text-sm mb-4"><em class="muted">Run to view letters…</em></div>

        <h4 class="text-sm font-semibold">Human Grouping (cosmetic only)</h4>
        <div id="groupedBox" class="result rounded p-3 text-sm"><em class="muted">Run to view grouping…</em></div>
      </div>

      <!-- Panel: Confidence -->
      <div class="card p-5 rounded">
        <h3 class="text-lg font-semibold mb-2">Confidence</h3>
        <div class="w-full h-8 bg-gray-700 rounded overflow-hidden">
          <div id="gaugeFill" class="h-full bg-gradient-to-r from-red-500 to-green-500 transition-all duration-700" style="width:0%"></div>
        </div>
        <div class="flex justify-between mt-2 text-xs muted">
          <span>0%</span><span id="confidenceLabel" class="text-sm font-semibold text-gray-300">0%</span><span>100%</span>
        </div>
        <p class="muted text-sm mt-2">
          Confidence is derived from <span class="font-semibold">coverage</span> and how the true key ranks against alternative keys (key-swap calibration).
        </p>
      </div>
    </section>
  </main>
</div>

<script>
/* ============ UI wiring ============ */
const tabBeale = document.getElementById('tabBeale');
const tabBook  = document.getElementById('tabBook');
const tabFree  = document.getElementById('tabFree');

const leftTitle = document.getElementById('leftTitle');
const leftHelp  = document.getElementById('leftHelp');

const inputBeale = document.getElementById('inputBeale');
const bookInputs = document.getElementById('bookInputs');
const freeInputs = document.getElementById('freeInputs');
const bookNums   = document.getElementById('bookNums');
const bookKey    = document.getElementById('bookKey');
const freeSeed   = document.getElementById('freeSeed');

const runBtn     = document.getElementById('runBtn');
const downloadBtn= document.getElementById('downloadBtn');
const warn       = document.getElementById('warn');

const lettersBox = document.getElementById('lettersBox');
const groupedBox = document.getElementById('groupedBox');
const covLabel   = document.getElementById('covLabel');
const rankLabel  = document.getElementById('rankLabel');
const gaugeFill  = document.getElementById('gaugeFill');
const confLabel  = document.getElementById('confidenceLabel');

let mode = 'beale';
let lastArtifacts = null;

function setTab(btn){
  [tabBeale,tabBook,tabFree].forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
}

function resetOutputs(){
  lettersBox.innerHTML = '<em class="muted">Run to view letters…</em>';
  groupedBox.innerHTML = '<em class="muted">Run to view grouping…</em>';
  covLabel.textContent = '—';
  rankLabel.textContent = '—';
  gaugeFill.style.width = '0%';
  confLabel.textContent = '0%';
  warn.textContent = '';
  downloadBtn.classList.add('hidden');
  lastArtifacts = null;
}

tabBeale.onclick = () => {
  mode = 'beale'; setTab(tabBeale); resetOutputs();
  leftTitle.textContent = 'Beale Paper “2” — Paste the pamphlet excerpt';
  leftHelp.textContent  = 'Include the numbered Declaration block and the long number list for Paper “2”. The tool will extract the DOI wordlist and decode strictly by first-letter indexing.';
  inputBeale.classList.remove('hidden');
  bookInputs.classList.add('hidden');
  freeInputs.classList.add('hidden');
};

tabBook.onclick = () => {
  mode = 'book'; setTab(tabBook); resetOutputs();
  leftTitle.textContent = 'Generic Book-Cipher — Numbers + Key';
  leftHelp.textContent  = 'Paste cipher numbers (commas/spaces) and a candidate key/book text. Decoding uses the classic rule: take the first letter of word N.';
  inputBeale.classList.add('hidden');
  bookInputs.classList.remove('hidden');
  freeInputs.classList.add('hidden');
};

tabFree.onclick = () => {
  mode = 'free'; setTab(tabFree); resetOutputs();
  leftTitle.textContent = 'Free-Text Generator (sandbox)';
  leftHelp.textContent  = 'Produces stylistic prose from your seed text. Not cryptanalysis; confidence remains low.';
  inputBeale.classList.add('hidden');
  bookInputs.classList.add('hidden');
  freeInputs.classList.remove('hidden');
};

/* ============ Crypto helpers (deterministic) ============ */
function extractDeclarationWordlist(pamphlet){
  const parts = pamphlet.split(/DECLARATION OF INDEPENDENCE/i);
  if (parts.length < 2) throw new Error('Declaration block not found.');
  const tail = parts[1];
  const pairs = [...tail.matchAll(/([A-Za-z&]+)\((\d+)\)/g)];
  if (!pairs.length) throw new Error('No Word(index) pairs found in DOI block.');
  const maxIdx = Math.max(...pairs.map(p => parseInt(p[2],10)));
  const words = Array(maxIdx+1).fill('');
  for (const p of pairs) words[parseInt(p[2],10)] = p[1].toUpperCase();
  return words; // 1-indexed
}

function extractBeale2Numbers(pamphlet){
  let m = pamphlet.match(/is\s+as\s+follows\s*:\s*([\s\S]+?)\n\n/i);
  if (!m) m = pamphlet.match(/((?:\d{1,5}\s*,\s*){10,}[\d\s,]+)/);
  if (!m) throw new Error('Cipher #2 number list not found.');
  return m[1].match(/\d+/g).map(n=>parseInt(n,10));
}

function parseNumberList(s){
  const nums = (s.match(/\d+/g)||[]).map(n=>parseInt(n,10));
  if (!nums.length) throw new Error('No numbers found.');
  return nums;
}

function normalizeBook(text){
  const toks = (text.toUpperCase().match(/[A-Z]+/g)||[]);
  return [''].concat(toks); // 1-indexed
}

function decodeFirstLetter(numbers, bookWords1Idx){
  const N = bookWords1Idx.length - 1;
  let bad=0, out=[];
  for (const n of numbers){
    if (1<=n && n<=N && bookWords1Idx[n]) out.push(bookWords1Idx[n][0]);
    else { out.push('?'); bad++; }
  }
  return { letters: out.join(''), bad };
}

function groupLetters(s){
  const words=[]; for (let i=0;i<s.length;i+=8) words.push(s.slice(i,i+8));
  return words.join(' ');
}

function altKeyCalibration(numbers, coverageTrue){
  const alts = [
    ['Constitution (preamble)', 'We the People of the United States in Order to form a more perfect Union establish Justice insure domestic Tranquility provide for the common defence promote the general Welfare and secure the Blessings of Liberty to ourselves and our Posterity do ordain and establish this Constitution for the United States of America'],
    ['Genesis 1 (KJV excerpt)', 'In the beginning God created the heaven and the earth And the earth was without form and void and darkness was upon the face of the deep And the Spirit of God moved upon the face of the waters'],
    ['Moby Dick (opening)', 'Call me Ishmael Some years ago never mind how long precisely having little or no money in my purse and nothing particular to interest me on shore']
  ];
  const res=[];
  for (const [label, text] of alts){
    const words = normalizeBook(text);
    const {bad} = decodeFirstLetter(numbers, words);
    const cov = (numbers.length - bad)/numbers.length;
    res.push({label, coverage: cov});
  }
  const worse = res.filter(r=>r.coverage >= coverageTrue).length;
  const rank = 1 + worse; // 1 = best
  return { rank, res };
}

function confidenceFrom(coverage, rank, totalAlt){
  const covScore = Math.max(0, Math.min(1, coverage));
  const rankScore = (totalAlt + 1 - rank)/(totalAlt + 1);
  const score = 0.7*covScore + 0.3*rankScore;
  return Math.round(100*score);
}

/* ============ Runner ============ */
runBtn.onclick = () => {
  resetOutputs();
  try {
    if (mode === 'beale') {
      const txt = inputBeale.value.trim();
      if (!txt) throw new Error('Paste the pamphlet excerpt first.');
      const words = extractDeclarationWordlist(txt);
      const nums  = extractBeale2Numbers(txt);
      const {letters, bad} = decodeFirstLetter(nums, words);
      const coverage = (nums.length - bad)/nums.length;
      const {rank, res} = altKeyCalibration(nums, coverage);
      const conf = confidenceFrom(coverage, rank, res.length);

      lettersBox.textContent = letters.slice(0,5000);
      groupedBox.textContent = groupLetters(letters).slice(0,5000);
      covLabel.textContent   = (coverage*100).toFixed(1)+'%';
      rankLabel.textContent  = `#${rank} of ${res.length+1}`;
      gaugeFill.style.width  = conf+'%';
      confLabel.textContent  = conf+'%';
      warn.textContent       = 'Declaration block detected; decode depends on that key (as intended in this mode).';

      lastArtifacts = {
        mode:'beale2',
        counts:{N:nums.length, unmapped:bad, coverage},
        alt_keys:res,
        letters_preview: letters.slice(0,200),
        letters_all: letters
      };
      downloadBtn.classList.remove('hidden');
    }

    if (mode === 'book') {
      const numsText = bookNums.value.trim();
      const keyText  = bookKey.value.trim();
      if (!numsText) throw new Error('Paste cipher numbers.');
      if (!keyText)  throw new Error('Paste the candidate key text.');
      const nums  = parseNumberList(numsText);
      const words = normalizeBook(keyText);
      const {letters, bad} = decodeFirstLetter(nums, words);
      const coverage = (nums.length - bad)/nums.length;
      // compare against three built-in alt keys for a sanity baseline
      const {rank, res} = altKeyCalibration(nums, coverage);
      const conf = confidenceFrom(coverage, rank, res.length);

      lettersBox.textContent = letters.slice(0,5000);
      groupedBox.textContent = groupLetters(letters).slice(0,5000);
      covLabel.textContent   = (coverage*100).toFixed(1)+'%';
      rankLabel.textContent  = `#${rank} of ${res.length+1}`;
      gaugeFill.style.width  = conf+'%';
      confLabel.textContent  = conf+'%';
      warn.textContent       = 'Strict letters-only mapping shown. Grouping is cosmetic; no paraphrasing applied.';

      lastArtifacts = {
        mode:'book_cipher',
        counts:{N:nums.length, unmapped:bad, coverage},
        alt_keys:res,
        letters_preview: letters.slice(0,200),
        letters_all: letters
      };
      downloadBtn.classList.remove('hidden');
    }

    if (mode === 'free') {
      const seed = freeSeed.value.trim();
      const words = (seed.match(/\b[A-Za-z]{3,}\b/g)||[]).slice(0,100);
      const out = `The pattern whispers through its own geometry; the rest is projection.\n\n`+
                  words.join(' ') + (words.length? ' …':'');
      lettersBox.textContent = out;
      groupedBox.textContent = out;
      covLabel.textContent = 'n/a';
      rankLabel.textContent = 'n/a';
      gaugeFill.style.width = '15%';
      confLabel.textContent = '15%';
      warn.textContent = 'Sandbox prose; not cryptanalysis.';
      lastArtifacts = {mode:'free_text', preview: out};
      downloadBtn.classList.remove('hidden');
    }

  } catch(e){
    lettersBox.innerHTML = `<span class="text-red-400">Error:</span> ${e.message}`;
  }
};

downloadBtn.onclick = () => {
  if (!lastArtifacts) return;
  const a = document.createElement('a');
  a.href = 'data:text/json;charset=utf-8,'+encodeURIComponent(JSON.stringify(lastArtifacts,null,2));
  a.download = (lastArtifacts.mode||'artifacts')+'.json';
  a.click();
};
</script>
</body>
</html>

What’s improved (and why it matters)

Strict, letters-only pipeline: no paraphrasing; what you see is exactly what the index→book→first-letter rule yields.

Key-dependence demonstrated: alt-key calibration and rank fold into the confidence, so the gauge is honest.

Two workflows:

Beale #2 verification (you paste the pamphlet excerpt that already includes the numbered Declaration).

Generic book-cipher (you supply numbers and any candidate book/key).

Artifacts for your ledger: click “Download JSON” to archive coverage, alt-key stats, and the raw letter stream.