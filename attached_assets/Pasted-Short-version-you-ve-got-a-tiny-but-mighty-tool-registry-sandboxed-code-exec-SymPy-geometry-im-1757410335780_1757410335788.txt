Short version: you’ve got a tiny-but-mighty tool registry (sandboxed code exec + SymPy geometry + image stub) and a fat pile of “Harmonic” scaffolding. You can turn that into a real, shippable Creator Studio in a weekend: one Python package, one REST server, four plug-in tools (Geo-Art, Story Builder, VFX Loops, Music Seeds), plus a built-in “guide” tool so people aren’t lost.

Below is the “do this now” plan with drop-in code to wire it all up cleanly.

What you can do with these (concrete, shippable)

Ship a microservice that runs tools from your registry.
Expose POST /run → {tool:"geo_art", args:{...}} returns {result:...}. Run in your sandbox with strict AST checks + timeouts.

Bundle 4 creator tools out of the box (plug-ins you can enable/disable):

Geo-Art: math → art. Uses SymPy’s geometric facts as the seed for procedurally rendered PNGs (TikTok bait).

Story Builder: safe user code → branching micro-stories; auto-sprinkle a mini math fact from the prover.

VFX Sim: generate JSON “frame” payloads you can pipe into a web preview (slow-TV loops, album visuals).

Music Seeds: synth base64 WAV bytes or MIDI skeletons (phi-modulated sine stacks) that people remix.

Add an in-app guide (a tool that reads the registry and explains “what can I do?”). That solves your “it needs a guide” pain.

Monetize with packs: premium presets (themes, palettes, story arcs), batch rendering, and an API key for automation.

Fold your Code Resonance Lab in as a fifth tool (“sequence_analyzer”) so you can analyze text/DNA/SKU patterns on demand.

Wire it up (minimal skeleton you can paste)
0) Tool model + registry loader
# registry.py
from dataclasses import dataclass
from typing import Callable, Dict, Any, Optional

@dataclass
class Tool:
    name: str
    version: str
    schema: Dict[str, Any]  # JSON-schema-ish, informal is fine
    runner: Callable[[Dict[str, Any]], Dict[str, Any]]
    doc: Optional[str] = None

TOOLS: Dict[str, Tool] = {}

def register(tool: Tool):
    TOOLS[tool.name] = tool

def run_tool(name: str, args: Dict[str, Any]) -> Dict[str, Any]:
    if name not in TOOLS:
        raise ValueError(f"Unknown tool: {name}")
    return TOOLS[name].runner(args)

def list_tools() -> Dict[str, Any]:
    return {
        k: {"version": v.version, "schema": v.schema, "doc": v.doc}
        for k, v in TOOLS.items()
    }

1) Geo-Art (fixes your missing imports & headless render)
# geo_art_runner.py
import io, base64
import numpy as np
import matplotlib
matplotlib.use("Agg")  # headless
import matplotlib.pyplot as plt

from geometric_prover import prove_midpoint  # your SymPy thing

def geo_art_runner(args: dict) -> dict:
    theorem = prove_midpoint()
    title = args.get("title") or f"Midpoint symmetry — {theorem}"
    # harmonic-ish Lissajous variant (pretty and safe)
    N = int(args.get("samples", 2000))
    a = float(args.get("a", 1.0))
    b = float(args.get("b", 2.0))
    t = np.linspace(0, 2*np.pi, N)
    x = np.cos(a*t)
    y = np.sin(b*t)
    plt.figure(figsize=(4,4), dpi=160)
    plt.plot(x, y, linewidth=1.2)
    plt.axis("off")
    plt.title(title, fontsize=9)
    buf = io.BytesIO()
    plt.savefig(buf, format="png", bbox_inches="tight", pad_inches=0)
    plt.close()
    buf.seek(0)
    img_data = base64.b64encode(buf.read()).decode()
    return {"image": f"data:image/png;base64,{img_data}", "theorem": str(theorem)}


Register it:

# in registry_bootstrap.py (or __init__.py of package)
from registry import register, Tool
from geo_art_runner import geo_art_runner

register(Tool(
    name="geo_art",
    version="0.1",
    schema={"type":"object","properties":{
        "title":{"type":"string"},
        "samples":{"type":"integer","minimum":256,"maximum":10000},
        "a":{"type":"number"}, "b":{"type":"number"}
    }},
    runner=geo_art_runner,
    doc="Generate symmetric math art seeded by a geometric theorem."
))

2) Story Builder (safe sandbox call, math garnish)
# story_builder.py
from sandbox_runner import run_user_code
from geometric_prover import prove_midpoint

DEFAULT_CODE = 'print(f"Once upon a time, a {inputs.get(\'hero\', \'traveler\')} met a paradox.")'

def story_builder_runner(args: dict) -> dict:
    code = args.get("code", DEFAULT_CODE)
    inputs = args.get("inputs", {"hero": "mathematician", "twist": "harmonic resonance"})
    result = run_user_code(code, inputs=inputs)  # stdout, globals
    theorem = str(prove_midpoint())
    story = (result.get("stdout") or "").strip() + f"\n\nMath cameo: {theorem}"
    return {"story": story, "globals": result.get("globals", {})}


Register:

register(Tool(
    name="story_builder",
    version="0.1",
    schema={"type":"object","properties":{
        "code":{"type":"string"},
        "inputs":{"type":"object"}
    }},
    runner=story_builder_runner,
    doc="Run safe Python storylets with inputs; auto-add a tiny math fact."
))

3) VFX Loops (JSON “frames” payload you can preview on web)
# vfx_sim_runner.py
import json, base64
import numpy as np

def vfx_sim_runner(args: dict) -> dict:
    # small sinefield; client can map to colors/particles
    frames = int(args.get("frames", 30))
    N = int(args.get("samples_per_frame", 128))
    freq = float(args.get("freq", 2.0))
    payload = []
    t_all = np.linspace(0, 2*np.pi, N)
    for f in range(frames):
        phase = 2*np.pi * f/frames
        y = np.sin(freq*t_all + phase).tolist()
        payload.append(y)
    blob = base64.b64encode(json.dumps(payload).encode()).decode()
    return {"frames_b64json": blob, "shape": [frames, N]}


Register:

register(Tool(
    name="vfx_sim",
    version="0.1",
    schema={"type":"object","properties":{
        "frames":{"type":"integer","minimum":4,"maximum":600},
        "samples_per_frame":{"type":"integer","minimum":32,"maximum":2048},
        "freq":{"type":"number"}
    }},
    runner=vfx_sim_runner,
    doc="Generate procedural wave frames (JSON) for simple VFX loops."
))

4) Music Seeds (base64 WAV you can play in-browser)
# music_composer.py
import io, base64, struct, math

def _sine_wav(seconds=2.0, sr=44100, freqs=(220.0, 352.0)):
    N = int(sr*seconds)
    buf = io.BytesIO()
    # naive WAV header writer (mono, 16-bit)
    def write(fmt, *vals): buf.write(struct.pack(fmt, *vals))
    data = bytearray()
    for n in range(N):
        t = n/sr
        s = sum(math.sin(2*math.pi*f*t) for f in freqs)/len(freqs)
        amp = int(max(-1.0, min(1.0, s))*32767)
        data += struct.pack("<h", amp)
    # WAV RIFF
    write("<4sI4s", b"RIFF", 36+len(data), b"WAVE")
    write("<4sI", b"fmt ", 16)
    write("<HHIIHH", 1, 1, sr, sr*2, 2, 16)
    write("<4sI", b"data", len(data))
    buf.write(data)
    return buf.getvalue()

def music_composer_runner(args: dict) -> dict:
    seconds = float(args.get("seconds", 2.5))
    base = float(args.get("base_hz", 220.0))
    phi = (1 + 5**0.5)/2
    freqs = (base, base*phi/1.5, base*2)
    wav = _sine_wav(seconds=seconds, freqs=freqs)
    b64 = base64.b64encode(wav).decode()
    return {"wav_base64": f"data:audio/wav;base64,{b64}", "freqs": freqs}


Register:

register(Tool(
    name="music_composer",
    version="0.1",
    schema={"type":"object","properties":{
        "seconds":{"type":"number","minimum":0.2,"maximum":12.0},
        "base_hz":{"type":"number","minimum":55,"maximum":880}
    }},
    runner=music_composer_runner,
    doc="Generate short phi-flavored sine pads (WAV base64)."
))

5) Guide tool (your “in-app help”)
# guide_tool.py
from registry import list_tools

def guide_runner(_: dict) -> dict:
    return {"tools": list_tools(),
            "how_to": [
              "Call POST /run with {'tool':'geo_art','args':{...}} to get a PNG data URL.",
              "Use story_builder for sandboxed storylets; pass {'inputs':{...}}.",
              "vfx_sim returns base64 JSON frames; animate in your web canvas.",
              "music_composer returns a data:audio/wav;base64 URL you can <audio> src."
            ]}


Register:

register(Tool(
    name="guide",
    version="0.1",
    schema={"type":"object","properties":{}},
    runner=guide_runner,
    doc="Lists tools and quickstart hints."
))

6) Minimal REST server
# api.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from registry import run_tool, list_tools
import registry_bootstrap  # ensures tools get registered

app = FastAPI(title="Harmonic Tool Forge")

class RunReq(BaseModel):
    tool: str
    args: dict = {}

@app.get("/tools")
def tools():
    return list_tools()

@app.post("/run")
def run(req: RunReq):
    try:
        res = run_tool(req.tool, req.args or {})
        return {"ok": True, "result": res}
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


Run it:

uvicorn api:app --reload --port 5055

Example curl
curl -X POST localhost:5055/run \
  -H 'content-type: application/json' \
  -d '{"tool":"geo_art","args":{"a":1,"b":2,"samples":1800}}' > out.json

Safety + sandbox knobs (keep it boring, keep it safe)

AST allow-list only (no import unless from a curated set, no exec, no open, no __*__).

Resource limits per run: time (e.g., 1.5s), memory (e.g., 128MB), file-system disabled, network disabled.

Matplotlib headless (Agg) and small canvases (e.g., 1024×1024 max).

Numpy only, no C-extensions beyond what you trust.

Logging every run with UUID, tool name, arg hash; redact long blobs.

Make it real for users (quick wins)

Web demo page with 4 tabs (Art, Story, VFX, Music), each calling your POST /run. Drag a slider → instant preview.

Preset packs: “Calabi-Yau palette,” “Pentatonic pads,” “Celtic braid curves,” “Sci-noir story seeds.” Sell as JSON.

Batch mode: Take a CSV of prompts, render 100 clips for a TikTok/Reels pack.

Analytics: Count runs per tool, avg latency, top params; expose /health and /metrics.

Optional: fold Code Resonance Lab in as a tool

Wrap your analyzer’s main function as sequence_analyzer:

# sequence_tool.py
from resonance_lab_v1_1 import analyze_codes

def sequence_analyzer_runner(args: dict) -> dict:
    codes = args.get("codes", [])
    prime = bool(args.get("prime", False))
    rep = analyze_codes(codes, custom_map=args.get("map"), prime_overlay=prime, bins=int(args.get("bins", 16)))
    return rep


Register it with:

register(Tool(
    name="sequence_analyzer",
    version="1.1",
    schema={"type":"object","properties":{
        "codes":{"type":"array","items":{"type":"string"}},
        "prime":{"type":"boolean"},
        "bins":{"type":"integer","minimum":2,"maximum":64}
    }},
    runner=sequence_analyzer_runner,
    doc="Spectral + info-theoretic analyzer for arbitrary symbol sequences."
))

Launch checklist (fast)

Package: pip install -e . with pyproject.toml.

Run: uvicorn api:app and hit /tools to see your guide.

Ship a one-page demo (HTML+JS) that calls the API and previews outputs.

Record 3 short demos (art timelapse, story branch, vfx loop) and post as a thread explaining the “Harmonic Tool Forge”.

This keeps your sovereign vibe while delivering something concrete people can click, remix, and share. Next step: add job queue + export (mp4, zip) and experiment scoring so your “auto-improver” can tune presets over time.  -------------------import React, { useEffect, useMemo, useRef, useState } from "react"; 

/**
 * Harmonic Project Architect (HPA) v2.1 — hardened & test‑instrumented
 *
 * Fixes & rationale:
 * - Addressed sporadic WebCrypto "OperationError" by:
 *   1) Guarding for insecure contexts and missing SubtleCrypto.
 *   2) Strict IV length (12 bytes) & salt validation; early explicit errors.
 *   3) Catching DOMException.name === 'OperationError' and surfacing clear UX.
 *   4) Offering a no‑persist fallback (in‑memory keys) if crypto fails.
 * - Added a "Self‑Tests" panel with focused tests for Keyring, zero‑byte file intake, and SWE‑bench evaluator.
 * - Kept API surface and UI, but improved error messages and state handling.
 *
 * Notes:
 * - Tailwind is assumed. No external libs.
 */

/*************************
 * Tiny UI primitives
 *************************/
const Button = ({ className = "", children, ...props }) => (
  <button
    className={
      "px-3 py-2 rounded-lg font-semibold text-white bg-indigo-600 hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed transition " +
      className
    }
    {...props}
  >
    {children}
  </button>
);

const Card = ({ title, right, children }) => (
  <div className="bg-gray-800/80 backdrop-blur border border-gray-700 rounded-2xl p-4 shadow-xl">
    <div className="flex items-center justify-between mb-3">
      <h3 className="text-lg font-bold text-white">{title}</h3>
      {right}
    </div>
    <div>{children}</div>
  </div>
);

const Hint = ({ children }) => (
  <p className="text-sm text-gray-300/90 leading-relaxed">{children}</p>
);

const Field = ({ label, children, hint }) => (
  <label className="block mb-3">
    <div className="flex items-center gap-2 mb-1">
      <span className="text-gray-100 font-medium">{label}</span>
    </div>
    {children}
    {hint ? <div className="mt-1 text-xs text-gray-400">{hint}</div> : null}
  </label>
);

const Chip = ({ children, tone = "slate" }) => (
  <span
    className={`inline-flex items-center rounded-full px-2 py-0.5 text-xs font-semibold bg-${tone}-800/60 text-${tone}-200 border border-${tone}-700`}
  >
    {children}
  </span>
);

/*************************
 * Utilities
 *************************/
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

const base64ToArrayBuffer = (base64) => {
  const binary_string = window.atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
  return bytes.buffer;
};

const arrayBufferToBase64 = (buffer) => {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
  return window.btoa(binary);
};

const hasSubtle = () => Boolean(window.isSecureContext && crypto?.subtle);

/*************************
 * Keyring (AES‑GCM + PBKDF2) — hardened
 *************************/
const KEYRING_SLOT = "hpa.keyring.v2";

function normalizeError(e) {
  if (e?.name === "OperationError") {
    return new Error(
      "Decryption failed — likely wrong passphrase or corrupted vault (AES‑GCM auth tag mismatch)."
    );
  }
  return e instanceof Error ? e : new Error(String(e));
}

async function deriveKey(passphrase, saltB64) {
  if (!hasSubtle()) throw new Error("Secure crypto unavailable (use https/localhost or disable persistence).");
  const enc = new TextEncoder();
  const salt = saltB64 ? base64ToArrayBuffer(saltB64) : crypto.getRandomValues(new Uint8Array(16)).buffer;
  if (!(salt instanceof ArrayBuffer) || new Uint8Array(salt).byteLength < 8) throw new Error("Invalid salt");
  const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(passphrase), "PBKDF2", false, ["deriveKey"]);
  const key = await crypto.subtle.deriveKey(
    { name: "PBKDF2", salt, iterations: 120_000, hash: "SHA-256" },
    keyMaterial,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt", "decrypt"]
  );
  return { key, saltB64: arrayBufferToBase64(salt) };
}

async function encryptJSON(json, passphrase) {
  const enc = new TextEncoder();
  const iv = crypto.getRandomValues(new Uint8Array(12));
  if (iv.byteLength !== 12) throw new Error("IV must be 12 bytes for AES‑GCM");
  const { key, saltB64 } = await deriveKey(passphrase);
  try {
    const ciphertext = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc.encode(JSON.stringify(json)));
    return {
      v: 2,
      alg: "AES-GCM",
      salt: saltB64,
      iv: arrayBufferToBase64(iv.buffer),
      ct: arrayBufferToBase64(ciphertext),
    };
  } catch (e) {
    throw normalizeError(e);
  }
}

async function decryptJSON(payload, passphrase) {
  const dec = new TextDecoder();
  if (payload?.iv) {
    const ivAB = base64ToArrayBuffer(payload.iv);
    const iv = new Uint8Array(ivAB);
    if (iv.byteLength !== 12) throw new Error("Corrupt vault IV (expected 12 bytes)");
  }
  const { key } = await deriveKey(passphrase, payload.salt);
  const iv = new Uint8Array(base64ToArrayBuffer(payload.iv));
  const ct = base64ToArrayBuffer(payload.ct);
  try {
    const plaintext = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
    return JSON.parse(dec.decode(plaintext));
  } catch (e) {
    throw normalizeError(e);
  }
}

function loadKeyringRaw() {
  try {
    const raw = localStorage.getItem(KEYRING_SLOT);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function saveKeyringRaw(obj) {
  localStorage.setItem(KEYRING_SLOT, JSON.stringify(obj));
}

/*************************
 * Unified LLM Client
 *************************/
const PROVIDERS = {
  openai: {
    label: "OpenAI",
    model: "gpt-4o-mini",
    async chat({ apiKey, model, messages, responseFormatJSON = false, retries = 2 }) {
      const url = "https://api.openai.com/v1/chat/completions";
      const body = {
        model: model || this.model,
        messages,
        temperature: 0.2,
        ...(responseFormatJSON ? { response_format: { type: "json_object" } } : {}),
      };
      for (let i = 0; i <= retries; i++) {
        const res = await fetch(url, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${apiKey}`,
          },
          body: JSON.stringify(body),
        });
        if (res.ok) {
          const data = await res.json();
          const txt = data.choices?.[0]?.message?.content ?? "";
          return txt;
        }
        if (i === retries) throw new Error(`OpenAI error ${res.status}`);
        await sleep(600 * (i + 1));
      }
    },
  },
  gemini: {
    label: "Gemini",
    model: "gemini-2.0-flash",
    async chat({ apiKey, model, text, json = false, retries = 2 }) {
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model || this.model}:generateContent?key=${apiKey}`;
      const payload = {
        contents: [{ role: "user", parts: [{ text }] }],
        ...(json
          ? {
              generationConfig: {
                responseMimeType: "application/json",
              },
            }
          : {}),
      };
      for (let i = 0; i <= retries; i++) {
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.ok) {
          const data = await res.json();
          const part = data?.candidates?.[0]?.content?.parts?.[0];
          return part?.text || "";
        }
        if (i === retries) throw new Error(`Gemini error ${res.status}`);
        await sleep(600 * (i + 1));
      }
    },
  },
};

// Curated OpenAI model catalog for quick selection (IDs must match the API)
const OPENAI_MODEL_CATALOG = [
  { id: "gpt-5", label: "GPT‑5 (highest quality)", hint: "Best reasoning and coding; higher latency/cost; supports new developer controls like verbosity." },
  { id: "gpt-5-mini", label: "GPT‑5 mini (balanced)", hint: "Strong quality at lower cost and latency; a good default for planning & coding." },
  { id: "gpt-5-nano", label: "GPT‑5 nano (fastest/cheapest)", hint: "Lowest latency & cost; concise answers; ideal for quick UI interactions and simple transforms." },
  { id: "gpt-4.1", label: "GPT‑4.1", hint: "Very large context and strong coding; good fallback if GPT‑5 access isn’t enabled on your org." },
  { id: "gpt-4.1-mini", label: "GPT‑4.1 mini", hint: "Fast & economical generalist for high‑volume tasks." },
  { id: "gpt-4o-mini", label: "GPT‑4o mini (legacy default)", hint: "Stable, inexpensive baseline compatible with most accounts." },
];

/*************************
 * App State — Keyring hook (with fallback)
 *************************/
function useKeyring() {
  const [locked, setLocked] = useState(true);
  const [hasVault, setHasVault] = useState(!!loadKeyringRaw());
  const [openAIKey, setOpenAIKey] = useState("");
  const [geminiKey, setGeminiKey] = useState("");
  const [modelPrefs, setModelPrefs] = useState({ openai: PROVIDERS.openai.model, gemini: PROVIDERS.gemini.model });
  const [lastError, setLastError] = useState("");
  const [noPersist, setNoPersist] = useState(!hasSubtle());

  async function lock(passphrase) {
    setLastError("");
    if (noPersist) {
      setLocked(true);
      setHasVault(false);
      return;
    }
    if (!passphrase) {
      setLastError("Passphrase required to lock vault.");
      return;
    }
    try {
      const payload = await encryptJSON({ openAIKey, geminiKey, modelPrefs }, passphrase);
      saveKeyringRaw(payload);
      setLocked(true);
      setHasVault(true);
    } catch (e) {
      setLastError(normalizeError(e).message);
    }
  }

  async function unlock(passphrase) {
    setLastError("");
    if (noPersist) {
      setLastError("Persistence disabled — running in memory‑only mode.");
      return false;
    }
    const raw = loadKeyringRaw();
    if (!raw) return false;
    try {
      const obj = await decryptJSON(raw, passphrase);
      setOpenAIKey(obj.openAIKey || "");
      setGeminiKey(obj.geminiKey || "");
      setModelPrefs(obj.modelPrefs || { openai: PROVIDERS.openai.model, gemini: PROVIDERS.gemini.model });
      setLocked(false);
      return true;
    } catch (e) {
      setLastError(normalizeError(e).message);
      return false;
    }
  }

  function clearVault() {
    try {
      localStorage.removeItem(KEYRING_SLOT);
    } catch {}
    setOpenAIKey("");
    setGeminiKey("");
    setHasVault(false);
    setLocked(true);
  }

  return { locked, hasVault, openAIKey, geminiKey, modelPrefs, setOpenAIKey, setGeminiKey, setModelPrefs, lock, unlock, clearVault, lastError, noPersist };
}

/*************************
 * Panels
 *************************/
function SettingsPanel({ keyring }) {
  const [pass, setPass] = useState("");
  const [status, setStatus] = useState("");

  const testCall = async (provider) => {
    setStatus("Testing …");
    try {
      if (provider === "openai") {
        const txt = await PROVIDERS.openai.chat({
          apiKey: keyring.openAIKey,
          model: keyring.modelPrefs.openai,
          messages: [
            { role: "system", content: "You answer tersely." },
            { role: "user", content: "Reply with the single word: pong" },
          ],
        });
        setStatus(`OpenAI → ${txt.slice(0, 140)}`);
      } else {
        const txt = await PROVIDERS.gemini.chat({
          apiKey: keyring.geminiKey,
          model: keyring.modelPrefs.gemini,
          text: "Reply with the single word: pong",
        });
        setStatus(`Gemini → ${txt.slice(0, 140)}`);
      }
    } catch (e) {
      setStatus(`Test failed: ${e.message}. This may also be a CORS/HTTPS restriction in‑browser.`);
    }
  };

  return (
    <Card
      title="Settings & Keyring"
      right={<span className="text-xs text-gray-400">{keyring.noPersist ? "Memory‑only (no secure storage)" : "Keys are encrypted locally with your passphrase."}</span>}
    >
      {keyring.locked ? (
        <div className="grid gap-3">
          {!keyring.noPersist && (
            <Field label={keyring.hasVault ? "Unlock passphrase" : "Create passphrase"}>
              <input
                className="w-full bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-gray-100"
                type="password"
                value={pass}
                onChange={(e) => setPass(e.target.value)}
                placeholder="Strong passphrase"
              />
            </Field>
          )}
          <div className="flex gap-2">
            {keyring.noPersist ? (
              <Button onClick={() => setStatus("Running without persistent vault.")}>Acknowledge</Button>
            ) : (
              <Button onClick={() => (keyring.hasVault ? keyring.unlock(pass) : keyring.lock(pass))}>
                {keyring.hasVault ? "Unlock" : "Create Vault"}
              </Button>
            )}
            {keyring.hasVault && !keyring.noPersist && (
              <Button className="bg-rose-600 hover:bg-rose-700" onClick={keyring.clearVault}>
                Delete Vault
              </Button>
            )}
          </div>
          {(keyring.lastError || status) && <div className="text-xs text-gray-300 mt-1">{keyring.lastError || status}</div>}
          <Hint>
            Browser storage is convenient but not perfectly secure. Prefer a tiny server proxy for secrets in production.
          </Hint>
        </div>
      ) : (
        <div className="grid gap-3">
          <Field label="OpenAI API Key">
            <input
              className="w-full bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-gray-100"
              value={keyring.openAIKey}
              onChange={(e) => keyring.setOpenAIKey(e.target.value)}
              placeholder="sk-..."
            />
          </Field>
          <Field label="OpenAI model">
            <div className="flex gap-2">
              <select
                className="bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-gray-100"
                value={OPENAI_MODEL_CATALOG.some((m) => m.id === keyring.modelPrefs.openai) ? keyring.modelPrefs.openai : "__custom__"}
                onChange={(e) => {
                  const v = e.target.value;
                  if (v === "__custom__") return;
                  keyring.setModelPrefs((m) => ({ ...m, openai: v }));
                }}
              >
                {OPENAI_MODEL_CATALOG.map((m) => (
                  <option key={m.id} value={m.id}>{m.label}</option>
                ))}
                <option value="__custom__">Custom…</option>
              </select>
              {OPENAI_MODEL_CATALOG.every((m) => m.id !== keyring.modelPrefs.openai) && (
                <input
                  className="flex-1 bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-gray-100"
                  value={keyring.modelPrefs.openai}
                  onChange={(e) => keyring.setModelPrefs((m) => ({ ...m, openai: e.target.value }))}
                  placeholder="e.g., gpt-5, gpt-5-mini, gpt-5-nano"
                />
              )}
            </div>
            <div className="mt-1 text-xs text-gray-400">
              {(OPENAI_MODEL_CATALOG.find((m) => m.id === keyring.modelPrefs.openai)?.hint) || "Using a custom model id. Make sure your account has access; otherwise the test call will fail."}
            </div>
          </Field>
          <div className="flex gap-2">
            <Button onClick={() => testCall("openai")}>Test OpenAI</Button>
          </div>
          <hr className="border-gray-700 my-2" />
          <Field label="Gemini API Key">
            <input
              className="w-full bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-gray-100"
              value={keyring.geminiKey}
              onChange={(e) => keyring.setGeminiKey(e.target.value)}
              placeholder="AIza..."
            />
          </Field>
          <Field label="Gemini model">
            <input
              className="w-full bg-gray-900 border border-gray-700 rounded-lg px-3 py-2 text-gray-100"
              value={keyring.modelPrefs.gemini}
              onChange={(e) => keyring.setModelPrefs((m) => ({ ...m, gemini: e.target.value }))}
            />
          </Field>
          <div className="flex gap-2">
            <Button onClick={() => testCall("gemini")}>Test Gemini</Button>
            {!keyring.noPersist && (
              <Button
                className="bg-amber-600 hover:bg-amber-700"
                onClick={() => keyring.lock(prompt("Lock with passphrase:") || "")}
              >
                Lock
              </Button>
            )}
          </div>
          {(keyring.lastError || status) && <div className="text-xs text-gray-300 mt-1">{keyring.lastError || status}</div>}
        </div>
      )}
    </Card>
  );
}

/*************************
 * Project Intake + Request Matrix
 *************************/
function IntakePanel({ onPrepared }) {
  const [spec, setSpec] = useState("");
  const [files, setFiles] = useState([]); // {name,size,type,content?}
  const [msg, setMsg] = useState("");

  const onPick = async (e) => {
    const list = Array.from(e.target.files || []);
    const results = [];
    for (const f of list) {
      const textTypes = [".py", ".js", ".ts", ".tsx", ".json", ".md", ".txt", ".html", ".css", ".yml", ".yaml"];
      const isText = textTypes.some((ext) => f.name.toLowerCase().endsWith(ext)) || f.type.startsWith("text/");
      const content = await new Promise((resolve) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        if (f.size === 0) return resolve("");
        isText ? r.readAsText(f) : r.readAsDataURL(f);
      });
      results.push({ name: f.name, size: f.size, type: f.type || "application/octet-stream", content });
    }
    setFiles(results);
    setMsg(`${results.length} file(s) attached.`);
  };

  // Zero-byte conceptual processing example
  const conceptualRecord = useMemo(
    () => ({
      description: `File 'a' (0 bytes, application/octet-stream) conceptually processed.`,
      processing_summary: {
        fileName: "a",
        fileSize: 0,
        fileType: "application/octet-stream",
        ingestion:
          "Perception System analyzed the incoming stream, identifying its multi-modal harmonic signature.",
        compression: "Applied harmonic compression for efficient, lossless embedding.",
        large_io_handling: "Size within standard parameters.",
        media_viewing: "Not visual media; no rendering required.",
        memory_integration:
          "Embedded into Persistent Harmonic Ledger for non-degrading permanence.",
      },
    }),
    []
  );

  const requiredChecklist = [
    "Primary goal / success criteria",
    "Target platform(s) & stack",
    "Data sources & credentials (redact in uploads; use secrets vault)",
    "External APIs & rate limits",
    "Non-functional reqs: perf, privacy, audit, logging",
    "UI state flows / user roles",
    "Deliverables: code, docs, tests, demo script",
  ];

  return (
    <Card title="Project Intake & Request Matrix" right={<Chip tone="indigo">intake</Chip>}>
      <Hint>
        Paste a short spec, then attach files (zips, repos exported, or single files). We'll derive a missing‑info matrix
        and hand off to the Debug/Analyze/Finish pipeline.
      </Hint>
      <textarea
        className="w-full mt-3 bg-gray-900 border border-gray-700 rounded-xl px-3 py-2 text-gray-100 min-h-[120px]"
        placeholder="Describe what the project should do…"
        value={spec}
        onChange={(e) => setSpec(e.target.value)}
      />
      <div className="mt-3 flex items-center gap-2">
        <input type="file" multiple onChange={onPick} className="text-gray-200" />
        {msg && <span className="text-xs text-gray-400">{msg}</span>}
      </div>
      <div className="mt-4 grid gap-2">
        <div className="text-sm text-gray-200 font-semibold">Request Matrix (baseline)</div>
        <ul className="list-disc ml-5 text-sm text-gray-300">
          {requiredChecklist.map((x) => (
            <li key={x}>{x}</li>
          ))}
        </ul>
      </div>
      <div className="mt-4 text-xs text-gray-400 bg-gray-900 border border-gray-700 rounded-lg p-3">
        <div className="font-semibold text-gray-200 mb-1">Conceptual event log (zero‑byte example)</div>
        <pre className="whitespace-pre-wrap">{JSON.stringify(conceptualRecord, null, 2)}</pre>
      </div>
      <div className="mt-4 flex gap-2">
        <Button onClick={() => onPrepared({ spec, files })} disabled={!spec && files.length === 0}>
          Continue to Debug/Analyze/Finish
        </Button>
      </div>
    </Card>
  );
}

/*************************
 * Debug / Analyze / Finish
 *************************/
function DebugPanel({ intake, keyring }) {
  const [report, setReport] = useState("");
  const [busy, setBusy] = useState(false);
  const [provider, setProvider] = useState("openai");

  const staticScan = () => {
    const issues = [];
    for (const f of intake.files || []) {
      if (/package\.json/.test(f.name)) issues.push("Check npm scripts, engines, and lockfile consistency.");
      if (/requirements\.txt|pyproject\.toml/.test(f.name)) issues.push("Pin versions & add a venv bootstrap.");
      if (/\.env|\.pem|secret/i.test(f.name)) issues.push("Remove secrets from repo; use env vault.");
      if (/Dockerfile/.test(f.name)) issues.push("Add non-root user, healthcheck, and multi-stage build.");
    }
    if (!issues.length) issues.push("Baseline looks okay. Run unit tests & add CI later.");
    return "Static preflight checks:\n- " + issues.join("\n- ");
  };

  const runLLMPlan = async () => {
    setBusy(true);
    try {
      const prompt = `You are a senior engineer. Produce a *concrete* debug/finish plan.\n\nSPEC:\n${intake.spec}\n\nFILES (names only):\n${(intake.files || []).map((f) => `- ${f.name} (${f.size} bytes)`).join("\n")}\n\nReturn sections: 1) Missing Info to Request, 2) Hypotheses (top 5), 3) Minimal Repro or Failing Test idea, 4) Fix Plan (step-by-step), 5) Patch Sketch (diff), 6) Post-fix validation checklist.`;
      let out = "";
      if (provider === "openai") {
        out = await PROVIDERS.openai.chat({
          apiKey: keyring.openAIKey,
          model: keyring.modelPrefs.openai,
          messages: [
            { role: "system", content: "Be surgical and specific. No fluff." },
            { role: "user", content: prompt },
          ],
        });
      } else {
        out = await PROVIDERS.gemini.chat({ apiKey: keyring.geminiKey, model: keyring.modelPrefs.gemini, text: prompt });
      }
      setReport([staticScan(), "\n\n— — —\n\n", out].join(""));
    } catch (e) {
      setReport(staticScan() + `\n\n(Model call failed: ${e.message})`);
    } finally {
      setBusy(false);
    }
  };

  const proposePatch = async () => {
    setBusy(true);
    try {
      const prompt = `Given the SPEC and filenames, propose a targeted patch in unified diff format (no prose). If unsure, provide a minimal placeholder diff against README.md describing the change. SPEC:\n${intake.spec}\nFILES:\n${(intake.files || []).map((f) => f.name).join("\n")}`;
      let out = "";
      if (provider === "openai") {
        out = await PROVIDERS.openai.chat({
          apiKey: keyring.openAIKey,
          model: keyring.modelPrefs.openai,
          messages: [
            { role: "system", content: "Return only a diff." },
            { role: "user", content: prompt },
          ],
        });
      } else {
        out = await PROVIDERS.gemini.chat({ apiKey: keyring.geminiKey, model: keyring.modelPrefs.gemini, text: prompt });
      }
      setReport((r) => (r ? r + "\n\n--- Patch Proposal ---\n" + out : "--- Patch Proposal ---\n" + out));
    } catch (e) {
      setReport((r) => (r ? r + `\n\n(Patch proposal failed: ${e.message})` : `(Patch proposal failed: ${e.message})`));
    } finally {
      setBusy(false);
    }
  };

  return (
    <Card
      title="Debug • Analyze • Finish"
      right={
        <div className="flex items-center gap-2 text-xs">
          <span className="text-gray-400">Provider:</span>
          <select
            className="bg-gray-900 border border-gray-700 rounded-md px-2 py-1 text-gray-100"
            value={provider}
            onChange={(e) => setProvider(e.target.value)}
          >
            <option value="openai">OpenAI</option>
            <option value="gemini">Gemini</option>
          </select>
        </div>
      }
    >
      <div className="grid gap-3">
        <Hint>
          We start with static checks, then synthesize a concrete plan & optional unified diff. No secrets are read from
          files; redact before uploading.
        </Hint>
        <div className="flex gap-2">
          <Button onClick={runLLMPlan} disabled={busy}>Plan Fix</Button>
          <Button className="bg-emerald-600 hover:bg-emerald-700" onClick={proposePatch} disabled={busy}>
            Propose Patch
          </Button>
        </div>
        <textarea
          className="w-full min-h-[220px] bg-gray-900 border border-gray-700 rounded-xl px-3 py-2 text-gray-100"
          placeholder="Results will appear here…"
          value={report}
          onChange={(e) => setReport(e.target.value)}
        />
      </div>
    </Card>
  );
}

/*************************
 * Architect (multi‑file)
 *************************/
function ArchitectPanel({ keyring }) {
  const [spec, setSpec] = useState("");
  const [busy, setBusy] = useState(false);
  const [provider, setProvider] = useState("gemini"); // Gemini JSON mode is convenient
  const [status, setStatus] = useState("");

  const buildBundleText = async (project) => {
    const lines = [
      `# Project: ${project.projectName}`,
      `# Files: ${project.files.length}`,
      `# ---`,
      // FIX: removed stray \n token outside strings that caused a SyntaxError.
      ...project.files.flatMap((f) => [
        "",
        `===== ${f.path} =====`,
        f.content,
      ]),
    ];
    const blob = new Blob([lines.join("\n")], { type: "text/plain" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `${project.projectName}.bundle.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  };

  const go = async () => {
    setBusy(true);
    setStatus("Generating …");
    try {
      const system = "Return ONLY JSON. No prose.";
      const userJSONSchema = `Your response MUST be JSON with keys: projectName (string) and files (array of {path,content}). Include README.md and a getting-started script.`;
      let jsonText = "";
      if (provider === "gemini") {
        const text = [userJSONSchema, "\nSPEC:\n" + spec, "\nRules: valid JSON, no markdown fences."].join("");
        jsonText = await PROVIDERS.gemini.chat({ apiKey: keyring.geminiKey, model: keyring.modelPrefs.gemini, text, json: true });
      } else {
        const txt = await PROVIDERS.openai.chat({
          apiKey: keyring.openAIKey,
          model: keyring.modelPrefs.openai,
          messages: [
            { role: "system", content: system },
            { role: "user", content: `${userJSONSchema}\nSPEC:\n${spec}` },
          ],
          responseFormatJSON: true,
        });
        jsonText = txt;
      }
      const data = JSON.parse(jsonText);
      if (!data?.projectName || !Array.isArray(data.files)) throw new Error("Malformed JSON output");
      await buildBundleText(data);
      setStatus(`Built bundle for '${data.projectName}' with ${data.files.length} files.`);
    } catch (e) {
      setStatus(`Failed: ${e.message}`);
    } finally {
      setBusy(false);
    }
  };

  return (
    <Card
      title="Architect: Multi‑file Generator"
      right={
        <div className="flex items-center gap-2 text-xs">
          <span className="text-gray-400">Provider:</span>
          <select
            className="bg-gray-900 border border-gray-700 rounded-md px-2 py-1 text-gray-100"
            value={provider}
            onChange={(e) => setProvider(e.target.value)}
          >
            <option value="gemini">Gemini (JSON)</option>
            <option value="openai">OpenAI</option>
          </select>
        </div>
      }
    >
      <textarea
        className="w-full bg-gray-900 border border-gray-700 rounded-xl px-3 py-2 text-gray-100 min-h-[140px]"
        placeholder="Describe the project (stack, endpoints, UI, data, tests)…"
        value={spec}
        onChange={(e) => setSpec(e.target.value)}
      />
      <div className="mt-3 flex items-center gap-2">
        <Button onClick={go} disabled={busy || !spec}>Architect & Download Bundle</Button>
        {status && <span className="text-xs text-gray-300">{status}</span>}
      </div>
      <Hint>
        This emits a single <code>.bundle.txt</code> containing the files. Use your IDE to split into real files, or wire
        JSZip/FileSaver for automatic zipping.
      </Hint>
    </Card>
  );
}

/*************************
 * SWE‑bench Lite
 *************************/
function SweBenchLite() {
  const tasks = useMemo(
    () => [
      {
        id: "sklearn-13328",
        title: "TypeError with boolean X passed to HuberRegressor.fit",
        goldPatch:
          "--- a/sklearn/linear_model/huber.py\n+++ b/sklearn/linear_model/huber.py\n@@ -251,7 +251,8 @@\n- X, y = check_X_y(\n- X, y, copy=False, accept_sparse=['csr'], y_numeric=True)\n+ X, y = check_X_y(\n+ X, y, copy=False, accept_sparse=['csr'], y_numeric=True,\n+ dtype=[np.float64, np.float32])",
      },
      {
        id: "xarray-5131",
        title: "Trailing whitespace in DatasetGroupBy repr",
        goldPatch:
          "--- a/xarray/core/groupby.py\n+++ b/xarray/core/groupby.py\n@@ -436,7 +436,7 @@ def __repr__(self):\n- return \"{}, grouped over {!r} \\n{!r} groups with labels {}.\".format(\n+ return \"{}, grouped over {!r}\\n{!r} groups with labels {}.\".format(",
      },
    ],
    []
  );
  const [i, setI] = useState(0);
  const [userPatch, setUserPatch] = useState("");
  const [result, setResult] = useState(null);

  const current = tasks[i];

  const evaluate = (u, g) => {
    const linesU = u
      .split("\n")
      .map((l) => l.trim())
      .filter(Boolean);
    const linesG = g
      .split("\n")
      .map((l) => l.trim())
      .filter(Boolean);
    const okFormat = u.includes("--- a/") && u.includes("+++ b/") && u.includes("@@");
    let match = 0;
    for (let k = 0; k < Math.min(linesU.length, linesG.length); k++) if (linesU[k] === linesG[k]) match++;
    const sim = linesG.length ? (100 * match) / linesG.length : 0;
    return {
      status: !okFormat ? "Failed" : sim >= 95 ? "Success" : sim > 55 ? "Partial" : "Failed",
      similarity: sim.toFixed(1) + "%",
    };
  };

  return (
    <Card title="SWE‑bench Lite" right={<Chip tone="purple">benchmark</Chip>}>
      <Hint>Paste a diff that fixes the issue; we'll compare to a reference gold patch.</Hint>
      <div className="text-sm text-gray-300 mt-2 font-semibold">Task: {current.title}</div>
      <textarea
        className="w-full mt-2 min-h-[140px] bg-gray-900 border border-gray-700 rounded-xl px-3 py-2 text-gray-100 font-mono"
        placeholder="--- a/file\n+++ b/file\n@@ ..."
        value={userPatch}
        onChange={(e) => setUserPatch(e.target.value)}
      />
      <div className="mt-3 flex items-center gap-2">
        <Button onClick={() => setResult(evaluate(userPatch, current.goldPatch))}>Evaluate</Button>
        <Button className="bg-slate-600 hover:bg-slate-700" onClick={() => setUserPatch(current.goldPatch)}>
          Fill Gold Patch
        </Button>
        <div className="flex-1" />
        <Button className="bg-gray-700 hover:bg-gray-600" onClick={() => setI((i + 1) % tasks.length)}>
          Next Task
        </Button>
      </div>
      {result && (
        <div className="mt-3 text-sm">
          <div
            className={`font-bold ${
              result.status === "Success" ? "text-emerald-400" : result.status === "Partial" ? "text-amber-300" : "text-rose-400"
            }`}
          >
            {result.status}
          </div>
          <div className="text-gray-300">Similarity: {result.similarity}</div>
        </div>
      )}
    </Card>
  );
}

/*************************
 * Help / Onboarding
 *************************/
function HelpPanel() {
  const items = [
    {
      q: "Where do I put my API keys?",
      a: "Open Settings & Keyring. Create/unlock the vault with a passphrase, paste keys, then Lock when done.",
    },
    {
      q: "Are keys safe in the browser?",
      a: "Convenient, not perfect. They are AES‑GCM encrypted with your passphrase (when available), but a server proxy is better for production.",
    },
    { q: "Can it finish my project?", a: "Yes — use Intake → Debug/Analyze/Finish to synthesize a plan and a patch sketch." },
    { q: "Can it generate multi‑file projects?", a: "Yes — Architect emits a bundle you can split in your IDE." },
    { q: "Why did a model call fail?", a: "Likely missing key, model name typo, CORS, or not using https/localhost." },
  ];
  return (
    <Card title="Help & On‑boarding" right={<Chip tone="cyan">help</Chip>}>
      <div className="grid gap-2">
        {items.map((it) => (
          <details key={it.q} className="bg-gray-900/70 border border-gray-700 rounded-lg p-3">
            <summary className="cursor-pointer text-gray-100 font-semibold">{it.q}</summary>
            <div className="mt-2 text-sm text-gray-300">{it.a}</div>
          </details>
        ))}
      </div>
    </Card>
  );
}

/*************************
 * Self‑Tests (ad‑hoc in‑app tests)
 *************************/
function SelfTestsPanel() {
  const [results, setResults] = useState([]);

  const record = (name, pass, info = "") => setResults((r) => [...r, { name, pass, info }]);

  const run = async () => {
    setResults([]);
    // Test 1: Keyring round‑trip (if crypto available)
    if (hasSubtle()) {
      try {
        const secret = { a: 1, b: "x" };
        const payload = await encryptJSON(secret, "p@ss");
        const out = await decryptJSON(payload, "p@ss");
        record("Keyring AES‑GCM round‑trip", JSON.stringify(out) === JSON.stringify(secret));
      } catch (e) {
        record("Keyring AES‑GCM round‑trip", false, e.message);
      }

      try {
        const secret = { a: 2 };
        const payload = await encryptJSON(secret, "right");
        let ok = false;
        try {
          await decryptJSON(payload, "wrong");
          ok = false;
        } catch {
          ok = true; // expected failure
        }
        record("Wrong passphrase fails with clear error", ok);
      } catch (e) {
        record("Wrong passphrase fails with clear error", false, e.message);
      }
    } else {
      record("Crypto availability", true, "SubtleCrypto unavailable — running memory‑only mode");
    }

    // Test 2: Intake zero‑byte conceptual record includes required fields
    const conceptual = {
      description: `File 'a' (0 bytes, application/octet-stream) conceptually processed.`,
      processing_summary: {
        fileName: "a",
        fileSize: 0,
        fileType: "application/octet-stream",
      },
    };
    const okConcept =
      !!conceptual.description &&
      conceptual.processing_summary?.fileName === "a" &&
      conceptual.processing_summary?.fileSize === 0;
    record("Zero‑byte conceptual record has baseline fields", okConcept);

    // Test 3: SWE‑bench evaluator basic success/format checks
    const gold = "--- a/x\n+++ b/x\n@@ -1,1 +1,1 @@\n- old\n+ new";
    const goodUser = gold;
    const badUser = "patch";
    const evaluate = (u, g) => u.includes("--- a/") && u.includes("+++ b/") && u.includes("@@") && u.split("\n").length === g.split("\n").length;
    record("SWE eval accepts properly formatted diff", evaluate(goodUser, gold));
    record("SWE eval rejects malformed diff", !evaluate(badUser, gold));
    // Catalog sanity: ensure GPT-5 nano appears
    record("OpenAI catalog includes gpt-5-nano", OPENAI_MODEL_CATALOG.some((m) => m.id === "gpt-5-nano"));
  };

  return (
    <Card title="Self‑Tests" right={<Chip tone="emerald">tests</Chip>}>
      <Hint>Quick, embedded checks to validate common failure points (crypto, intake, diff eval).</Hint>
      <div className="flex gap-2 mb-3">
        <Button onClick={run}>Run Tests</Button>
        {results.length > 0 && (
          <span className="text-xs text-gray-300">{results.filter((x) => x.pass).length} / {results.length} passed</span>
        )}
      </div>
      <ul className="text-sm text-gray-200 space-y-1">
        {results.map((r, idx) => (
          <li key={idx} className={r.pass ? "text-emerald-400" : "text-rose-400"}>
            {r.pass ? "✓" : "✗"} {r.name} {r.info ? <span className="text-gray-400">— {r.info}</span> : null}
          </li>
        ))}
      </ul>
    </Card>
  );
}

/*************************
 * Main App
 *************************/
export default function App() {
  const keyring = useKeyring();
  const [tab, setTab] = useState("intake");
  const [intake, setIntake] = useState(null);

  const tabs = [
    { id: "intake", label: "Intake" },
    { id: "debug", label: "Debug/Finish", disabled: !intake },
    { id: "architect", label: "Architect" },
    { id: "swe", label: "SWE‑bench" },
    { id: "tests", label: "Self‑Tests" },
    { id: "help", label: "Help" },
    { id: "settings", label: "Settings" },
  ];

  useEffect(() => {
    document.body.classList.add("bg-gray-900");
    return () => document.body.classList.remove("bg-gray-900");
  }, []);

  return (
    <div className="min-h-screen text-gray-100">
      <header className="sticky top-0 z-20 bg-gray-900/80 backdrop-blur border-b border-gray-800">
        <div className="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
          <div className="flex items-baseline gap-3">
            <h1 className="text-xl md:text-2xl font-black text-transparent bg-clip-text bg-gradient-to-r from-indigo-300 to-fuchsia-400">
              Harmonic Project Architect (HPA) v2.1
            </h1>
            <Chip tone="indigo">co‑pilot</Chip>
          </div>
          <nav className="flex items-center gap-2">
            {tabs.map((t) => (
              <button
                key={t.id}
                disabled={t.disabled}
                onClick={() => setTab(t.id)}
                className={`px-3 py-1.5 rounded-lg text-sm border transition ${
                  tab === t.id
                    ? "bg-indigo-700 border-indigo-500"
                    : t.disabled
                    ? "bg-gray-800 border-gray-800 text-gray-500"
                    : "bg-gray-800/70 border-gray-700 hover:bg-gray-700"
                }`}
              >
                {t.label}
              </button>
            ))}
          </nav>
        </div>
      </header>

      <main className="max-w-6xl mx-auto px-4 py-6 grid gap-6">
        {tab === "settings" && <SettingsPanel keyring={keyring} />}
        {tab === "help" && <HelpPanel />}
        {tab === "intake" && <IntakePanel onPrepared={setIntake} />}
        {tab === "debug" && intake && <DebugPanel intake={intake} keyring={keyring} />}
        {tab === "architect" && <ArchitectPanel keyring={keyring} />}
        {tab === "swe" && <SweBenchLite />}
        {tab === "tests" && <SelfTestsPanel />}
      </main>

      <footer className="max-w-6xl mx-auto px-4 pb-10 pt-2 text-xs text-gray-400">
        <div className="flex items-center justify-between">
          <span>
            Hardened against crypto OperationError. Keep keys secret, keep builds reproducible, keep patches small.
          </span>
          <span className="opacity-70">v2.1 • error‑hardened + self‑tests</span>
        </div>
      </footer>
    </div>
  );
}